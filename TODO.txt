
QKV/FFN micro‑FSMs (later, if you need area/timing)

    Q1. Time‑multiplex matrixVectorMult for Q/K/V and W_O
        One MAC lane accumulates over HeadDimension/ModelDim with a “done” pulse.
        Turn qkvDoneSig/ffnDoneSig from True into the real pulses.


Hazard/overlap (once TDP is in place)

    H1. Overlap reads and writes
        While port A streams reads for t = 0..pos, port B writes K,V for row pos.
        Keep the t==pos bypass in streamHeadAttention to avoid read‑during‑write issues.



Numeric realism

    Using Float throughout with sin/cos/exp/softmax will not synthesize efficiently. For a hardware decoder you’ll want:
        Fixed‑point or bfloat16 datapath.
        RoPE via LUT or CORDIC.
        Softmax via two‑pass streaming log‑sum‑exp or a stable single‑pass approximation.
        Dot products accumulated sequentially to keep area reasonable.
    Clash supports Float, but resource usage will be enormous unless you scale model sizes way down.



What to change at a high level

A workable 5‑stage per‑layer micro‑architecture (each stage can itself iterate):

    S1: Pre‑norm and Q/K/V
        x̂ = RMSNorm_att(x)
        Q/K/V matmuls for the heads needed at this layer (MQA: compute K,V once per KV head group)
        Apply RoPE to Q and K at pos
        Write K,V[pos] to KV RAM

    S2: Score pass (sequential)
        For each head: stream K[t] for t=0..pos; accumulate s[t] = dot(Q, K[t]) * inv_sqrt_d
        Track max per head for softmax stability

    S3: Softmax and value pass (sequential)
        Re‑scan t=0..pos: a[t] = exp(s[t]−max)/sum; accumulate O_head += a[t]*V[t]

    S4: Output projection + residual
        O = concat_heads(O_head) · Wo
        x ← x + O

    S5: FFN (pre‑norm + SwiGLU + projection) + residual
        ŷ = RMSNorm_ffn(x)
        h1 = SiLU(ŷ·W1); h3 = ŷ·W3; z = (h1 ⊙ h3) · W2
        x ← x + z
